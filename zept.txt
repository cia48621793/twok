"""
only type is word
vaguely python-ish looking
<= 1k loc 1 pass compiler to native
globals start with @

operations are determined by context
    a = a + 4
does an addition
    push(a, 4)
optionally allocates a list and pushes 4 onto it
no type check because it can't tell anyway

x = "stuff" ===
    push(x, ord('s'))
    push(x, ord('t'))
    push(x, ord('u'))
    push(x, ord('f'))
    push(x, ord('f'))

all of:
    push, [...], "...", range
create lists
bump alloc + flush helpers for crappy gc?
    mempush/mempop save/restore bump pointer location
implicit mempush/mempop around __main__

saving to globals
    a = []
    mempush()
    # do stuff, filling a
    mempop()
    # this fails, a is garbage
    a

    @a = []
    mempush()
    # do stuff, filling @a
    mempop()
    # this is OK, globals are allocated outside of regular heap
    @a

how? @a is actually the pointer plus a bool for "is-allocated"
on shutdown, iterate all globals and free any that are allocations
list manipulation has to do a bit extra to free, etc.
or just free(@a) manually?

or maybe @ just means manual, and global-ness is specified separately
with global @a (and global a would be bad)

@a and a are different variables
if you return an @ from a function it should be assigned to an @
and vice-versa.

do the global magic business later


everything is an expression, no return
list mod functions return the list for chain

"""

def stuff():
    a = []
    push(a, 4)
    len(a)

def things(a):
    a + 4

def blorp(y):
    for x in range(y):
        print("wee")

def bleep(x):
    ret = [1, 2]
    if x < 5:
        push(ret, 99)
    else:
        push(ret, 3)
    ret

def __main__():
    print(itos(stuff()))
    things(99)
    blorp(5)
    bleep(4)
    bleep(9)

def x():
    if a and b or 


"""
operators, highest to lowest:

() []
* / mod
+ -
& | ^ ~            # note, fixed (relative to C) to be higher
<< >>
< <= > >= == !=
and or not
=

no ++
no += (though that could be added?)

"""

# vim: set ft=python:

